%load_ext autoreload
%autoreload 2
%matplotlib inline

import time
import lightgbm as lgb
import xgboost as xgb
import seaborn as sns
import matplotlib.pyplot as plt

from fbprophet import Prophet

def ignore_warn(*args, **kwargs):
    pass

from sklearn.metrics import r2_score, median_absolute_error, mean_absolute_error
from sklearn.metrics import median_absolute_error, mean_squared_error, mean_squared_log_error
from sklearn.model_selection import KFold
from scipy import stats
from plotly.offline import init_notebook_mode, iplot
from plotly import graph_objs as go

import statsmodels.api as sm
# Initialize plotly
init_notebook_mode(connected=True)
def mean_absolute_percentage_error(y_true, y_pred): 
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

pd.option_context("display.max_rows", 1000);
pd.option_context("display.max_columns", 1000);

from google.colab import files
uploaded = files.upload()

# Import Data ---------------------------------------------------------#
# Data Contains Date as index, Store #, Item #, $ Sales(y)
import numpy as np
import pandas as pd
import io
df_raw = pd.read_csv(io.StringIO(uploaded['train.csv'].decode('utf-8')), parse_dates=['date'], index_col=['date'])

# Plot Sales
# preparation: input should be float type
df_raw['sales'] = df_raw['sales'] * 1.0

# store types
sales_a = df_raw[df_raw.store == 2]['sales'].sort_index(ascending = True)
sales_b = df_raw[df_raw.store == 3]['sales'].sort_index(ascending = True) # solve the reverse order
sales_c = df_raw[df_raw.store == 1]['sales'].sort_index(ascending = True)
sales_d = df_raw[df_raw.store == 4]['sales'].sort_index(ascending = True)

f, (ax1, ax2, ax3, ax4) = plt.subplots(4, figsize = (12, 13))
c = '#386B7F'

ax1.plot(sales_a.resample('W').sum()) # W: weekly
ax2.plot(sales_b.resample('W').sum())
ax3.plot(sales_c.resample('W').sum())
ax4.plot(sales_d.resample('W').sum())

# Show All sales together, regardless of Store or Item
date_sales = df_raw.drop(['store','item'], axis= 1).copy()
y = date_sales['sales'].resample('MS').mean()  # month start frequency
plt.plot(y)

# See if weekly trend exists
df.groupby(['Week','store','item'])['y'].mean().reset_index()

# Prepare Forecast
prediction_size = 31 # Add 31 additional Dates
train_df = df[:-prediction_size] # Remove last 31 dates as test
train_df.tail(n=3)
train_df.head

# Fit Prophet
# Dataset only requires DATE and y
%%time
m = Prophet(yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=True)
m.fit(train_df[['ds','y']]);

# Prepare Forecast
# Create Dataframe with future dates, where same starting date as train data PLUS Predicion_Size Date after Train Data Date
future = m.make_future_dataframe(periods=prediction_size) 
future

# Freocast Prophet
%%time
forecast = m.predict(future)
forecast.tail(n=5)

# Plot Prophet
m.plot(forecast);
m.plot_components(forecast);

# Model Accuracy
forecast['y'] = df['y'].copy()

train_MAE =  "{:.2f}".format(np.mean(abs(forecast[:-prediction_size]['y'] - forecast[:-prediction_size]['yhat'])))
test_MAE = "{:.2f}".format(np.mean(abs(forecast[-prediction_size:]['y'] - forecast[-prediction_size:]['yhat'])))
print("Training MAE: {}".format(train_MAE))
print("Test MAE: {} ".format(test_MAE))


# Prophet with HOLIDAY -------------------------------------------------#
# LOWER and UPPER Window: if you wanted to include Christmas Eve in addition to Christmas youâ€™d include lower_window=-1,upper_window=0
playoffs = pd.DataFrame({
  'holiday' : 'playoff',
  'ds' : pd.to_datetime(['2013-01-12','2013-07-12','2013-12-24','2014-01-12', '2014-07-12', '2014-07-19',
                 '2014-07-02','2014-12-24', '2015-07-11','2015-12-24', '2016-07-17',
                 '2016-07-24', '2016-07-07','2016-07-24','2016-12-24','2017-07-17','2017-07-24','2017-07-07','2017-12-24']),
  'lower_window' : 0,
  'upper_window' : 2}
)
superbowls = pd.DataFrame({
  'holiday': 'superbowl',
  'ds': pd.to_datetime(['2013-01-01','2013-01-21','2013-02-14','2013-02-18',
'2013-05-27','2013-07-04','2013-09-02','2013-10-14','2013-11-11','2013-11-28','2013-12-25','2014-01-01','2014-01-20','2014-02-14','2014-02-17',
'2014-05-26','2014-07-04','2014-09-01','2014-10-13','2014-11-11','2014-11-27','2014-12-25','2015-01-01','2015-01-19','2015-02-14','2015-02-16',
'2015-05-25','2015-07-03','2015-09-07','2015-10-12','2015-11-11','2015-11-26','2015-12-25','2016-01-01','2016-01-18','2016-02-14','2016-02-15',
'2016-05-30','2016-07-04','2016-09-05','2016-10-10','2016-11-11','2016-11-24','2016-12-25','2017-01-02','2017-01-16','2017-02-14','2017-02-20',
'2017-05-29','2017-07-04','2017-09-04','2017-10-09','2017-11-10','2017-11-23','2017-12-25','2018-01-01','2018-01-15','2018-02-14','2018-02-19'
                       ]),
  'lower_window': 0,
  'upper_window': 3,
})

holidays = pd.concat((playoffs, superbowls))

# Fit and Forecast
%%time
m_holi = Prophet(yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=True, holidays=holidays)
m_holi.fit(train_df[['ds','y']]);
future_holi = m_holi.make_future_dataframe(periods=prediction_size)
future_holi.tail(n=3)

%%time
forecast_holi = m_holi.predict(future_holi)
forecast_holi.tail(n=3)

m_holi.plot(forecast_holi);
m_holi.plot_components(forecast_holi);

forecast_holi['y'] = df['y'].copy()

train_MAE =  "{:.2f}".format(np.mean(abs(forecast_holi[:-prediction_size]['y'] - forecast_holi[:-prediction_size]['yhat'])))
test_MAE = "{:.2f}".format(np.mean(abs(forecast_holi[-prediction_size:]['y'] - forecast_holi[-prediction_size:]['yhat'])))
print("Training MAE: {}".format(train_MAE))
print("Test MAE: {} ".format(test_MAE))

# Add Regressor  ---------------------------------------------------------#
df['x1'] =  np.where(df['y']>19, 1, 0)

prediction_size = 31 
train_df = df[:-prediction_size]
train_df.tail(n=3)
train_df.head

%%time
m = Prophet(yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=True)
m.add_regressor('x1')
m.fit(train_df[['ds','y','x1']]);

# Create Dataframe with date, where same starting date as train data PLUS Predicion_Size Date after Train Data Date
future = m.make_future_dataframe(periods=prediction_size) 
future

# Input of Model is ONLY Date
%%time
forecast = m.predict(df)
forecast.tail(n=5)

m.plot(forecast);
m.plot_components(forecast);

forecast['y'] = df['y'].copy()

train_MAE =  "{:.2f}".format(np.mean(abs(forecast[:-prediction_size]['y'] - forecast[:-prediction_size]['yhat'])))
test_MAE = "{:.2f}".format(np.mean(abs(forecast[-prediction_size:]['y'] - forecast[-prediction_size:]['yhat'])))
print("Training MAE: {}".format(train_MAE))
print("Test MAE: {} ".format(test_MAE))
